# **Bypassing Seccomp**

A large number of system calls are exposed to every userland process, many of which go unused for the entire lifetime of the process. Seccomp filtering provides a means for a process to specify a filter for incoming system calls. The filter is expressed as a Berkeley Packet Filter (BPF) program, similar to socket filters, but the data operated on pertains to the system call being made: the system call number and the system call arguments.

### **Seccomp Modes**
Seccomp has three primary modes:
1. **SECCOMP_MODE_STRICT** – Activates all security measures provided by Seccomp.
2. **SECCOMP_MODE_FILTER** – Allows the developer or user to restrict specific actions via filters.
3. **SECCOMP_MODE_DISABLED** – Disables Seccomp entirely on the machine.

We can identify which syscalls are blocked by the process using tools like `seccomp-tools`.

### **Bypassing Seccomp**
Bypassing Seccomp in userland is generally impossible unless there's an improper implementation. For demonstration purposes, let's consider the Gissa 2 challenge from the **Midnight Sun CTF Quals 2019**, where the Seccomp was implemented improperly and could be bypassed easily.

#### **Step 1: Inspect the Seccomp Filter**
We use the `seccomp-tools` to dump the filter information of the binary:

```bash
seccomp-tools dump ./gissa_igen
```

This will show which syscalls are blocked. In this example, we find that syscalls like `open`, `execve`, etc., are disabled. Upon closer inspection, we notice that the filter blocks syscalls with values greater than `0x40000000`.

#### **Step 2: Bypass the Seccomp Filter Using Syscall Offsets**
To bypass the filter, we can adjust the syscall number by adding an offset (`0x40000000`) to the original syscall number. This allows us to bypass the restrictions by calling syscalls that have been "masked."

**Example:**
If we want to use the `write` syscall, which is blocked, we can manipulate the syscall number like this:

- **Original syscall:**
    ```asm
    mov rdi, 0x1          ; File descriptor (stdout)
    mov rsi, 0xdeadbeef    ; Address of the buffer
    mov rdx, 0x100         ; Number of bytes to write
    mov rax, 0x1           ; Syscall number for 'write'
    syscall
    ```
  
- **Bypassed syscall:**
    By adding the offset `0x40000000` to the original syscall number, we get:
    ```asm
    mov rdi, 0x1           ; File descriptor (stdout)
    mov rsi, 0xdeadbeef     ; Address of the buffer
    mov rdx, 0x100          ; Number of bytes to write
    mov rax, 0x40000001     ; Bypassed syscall number for 'write'
    syscall
    ```

### **Advanced Bypassing Techniques**
Seccomp filters can be applied at different stages of process execution. If the Seccomp filter is applied early in the process and the process creates a child process, the child might not inherit the Seccomp filter, allowing us to exploit this loophole.

#### **Example: Google CTF 2020 (Write-Only Challenge)**
In this CTF challenge, all syscalls except `open` and `write` were blocked. To bypass this, we had to read sensitive data (like a flag) from the memory of a child process, which was not filtered.

### **Disabling Seccomp in Kernel**
Seccomp operates using the Berkeley Packet Filter and is managed by the kernel through the `__secure_computing` function. Information about a process's Seccomp settings is stored in the `seccomp` struct inside the `task_struct`. The kernel uses the `TIF_SECCOMP` flag to indicate that Seccomp is enabled for the current process.

#### **Step 3: Disabling Seccomp**
To disable Seccomp in the current process, we can manipulate the `TIF_SECCOMP` flag in the `task_struct`. The following code illustrates how to clear this flag:

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/cred.h>

MODULE_LICENSE("GPL");

void disable_seccomp(void) {
    current->thread_info.flags &= ~(_TIF_SECCOMP);
}
```

This kernel module clears the `TIF_SECCOMP` flag, disabling Seccomp for the current process.

#### **Step 4: Writing the Shellcode**
After writing the kernel module, we can disassemble it using `objdump`:

```bash
objdump -M intel -d (kernel module name)
```

This will give us the assembly code, which can then be converted into shellcode. However, when inspecting the generated shellcode, we notice that the `gs` register offset might be incorrect. This is because `fs` and `gs` registers are used to handle thread-specific data and are stored in **Model-Specific Registers (MSRs)**, which are accessible only in kernel mode. As such, we need to manually adjust the shellcode and use a tool like **defuse.ca** to generate the proper shellcode.

### **Conclusion**
Bypassing Seccomp depends heavily on the specific implementation and vulnerabilities within the system's configuration. Exploiting improper Seccomp configurations, using syscall offset manipulation, forking child processes, or even disabling Seccomp in kernel space are effective techniques that can be used to evade restrictions imposed by Seccomp. For further exploration, challenges like **BabyKernel Level 8.0** in **Pwn College** provide practical exercises for understanding and overcoming Seccomp-based protections.

