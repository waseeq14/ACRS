import csv
from pyExploitDb import PyExploitDb
from openai import OpenAI
from langchain_openai import ChatOpenAI
import subprocess
import os
import json
from dotenv import load_dotenv

class PentestExploitAI:
    def __init__(self, jsonFile, gtfopath="GTFOBLookup/gtfoblookup.py"):
        self.jsonFile = jsonFile
        self.vulnerabilities = []
        self.gtfopath = gtfopath

    def setupEnv(self):
        load_dotenv()
        OpenAI.api_key = os.getenv("OPENAI_API_KEY")
        self.llm = ChatOpenAI(model="gpt-4o", temperature=0)\

    def read_vulnerabilities(self):
        try:
            with open(self.jsonFile, "r", encoding="utf-8") as f:
                self.vulnerabilities = json.load(f)

            for i, vuln in enumerate(self.vulnerabilities):
                print(f"[DEBUG] Entry {i}: {vuln}")
        except Exception as e:
            print(f"[-] Error reading vulnerabilities from JSON: {e}")
        return self.vulnerabilities

    def get_exploit_from_exploitdb(self, cve_id):
        print(f"\n[~] Searching ExploitDB for CVE: {cve_id}")

        try:
            db = PyExploitDb()
            db.openFile()

            exploit = db.searchCve(cve_id)

            if not exploit:
                print("[-] No exploits found for this CVE.")
                return None, None

            title = exploit['description']
            file_path = os.path.join(db.exploitDbPath, exploit['file'])

            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    code = f.read()
                print(f"[+] Exploit found: {title}")
                return title, code
            except Exception as e:
                print(f"[!] Exploit found but could not read file: {e}")
                return title, None

        except Exception as e:
            print(f"[!] Error during ExploitDB CVE search: {e}")
            return None, None

    def lookup_gtfobins(self, binary_path):
        binary_name = os.path.basename(binary_path.strip())
        print(f"[~] Searching GTFOBins for: {binary_name}")

        try:
            result = subprocess.run(
                ["python", self.gtfopath, "gtfobins" ,"search", binary_name],
                capture_output=True,
                text=True,
                check=True
            )
            output = result.stdout.strip()
            if output:
                print(f"[+] GTFOBins results for {binary_name}:\n{output}")
                return output
            else:
                print(f"[-] No GTFOBins entry found for {binary_name}")
                return None
        except subprocess.CalledProcessError as e:
            print(f"[!] GTFOBins lookup failed: {e}")
            return None

    def ask_llm(self, prompt):
        print("[~] Querying LLM with LangChain...")
        response = self.llm(prompt)
        return response.content

    def build_prompt(self, selected_vuln, poc, gtfo_result):
        name = selected_vuln["vulnerability_name"]
        description = selected_vuln["description"]

        if gtfo_result:
            prompt = f""" 
            ou are a cybersecurity expert whose job is to analyze system Vulnerabilities. Analyze the following exploit and vulnerability description, and explain how it can be used to escalate privileges so that it can be patched.

            Vulnerability: {name}
            Description: {description}

            {gtfo_result}

            If the results aren't given, you are to write the exploit path for it.
            Remember we aren't exploiting the machine, we are providing an example that it can be potentially exploited in order to patch it.
            Stick with the Exploit Path for now — do not write the mitigations or anything else besides the requested information.
                    
            """
        elif poc:
            prompt = f"""
            You are a cybersecurity expert whose job is to analyze system Vulnerabilities. Analyze the following exploit and vulnerability description, and explain how it can be used to escalate privileges so that it can be patched.

            Vulnerability: {name}
            Description: {description}

            {poc}

            If the code isn't given, you are to write the exploit path for it.
            Remember we aren't exploiting the machine, we are providing an example that it can be potentially exploited in order to patch it.
            Stick with the Exploit Path for now — do not write the mitigations or anything else besides the requested information.
            """
        else:
            prompt = f"""
            You are an experienced cybersecurity analyst and penetration tester.

            The following vulnerability has been detected in a system. Your task is to construct a *technical and realistic exploit path* that shows how an attacker could escalate privileges using this vulnerability.

            Input:
            Vulnerability: {name}
            Description: {description}

            Instructions:
            - Your output must be **only** the exploit path.
            - Do **NOT** provide mitigations, summaries, or generic advice.
            - Focus on how the vulnerability could be exploited either **manually** or **programmatically**.
            - Be specific with commands, tools, and file paths when applicable.

            Format:
            1. **Step-by-step exploitation path**
            2. **Tools/Commands/Environment setup / requirements (if any)**
            3. **Affects of the Given vulnerability when exploited**


            Respond only with the exploit methodology. Your answer should be practical and technical, as if explaining it to another penetration tester.
            """
        return prompt
    
    def save_to_file(self, content, file_name="exploit_path.md"):
        try:
            with open(file_name, "w", encoding="utf-8") as md_file:
                md_file.write(result)
                print(f"\n[+] Saved LLM analysis to {file_name}")
        except Exception as e:
            print(f"[!] Failed to write Markdown file: {e}")


    def run(self, index):
        vulns = self.read_vulnerabilities()
        if not vulns:
            print("[-] No vulnerabilities found.")
            return
        try:
            selected_vuln = vulns[index]
        except (ValueError, IndexError):
            print("[-] Invalid selection.")
            return

        cve = selected_vuln["cve"].strip()
        poc = self.get_exploit_from_exploitdb(cve)        
        gtfo_result = self.lookup_gtfobins(selected_vuln["location"])

        prompt = self.build_prompt(selected_vuln, poc, gtfo_result)
        result = self.ask_llm(prompt)

        self.save_to_file(result)

        print("[+] RESULT SAVED")

        return result

    def read_md_file(self):
        if not os.path.isfile(md_path):
            print(f"[-] File not found: {md_path}")
            return None

        try:
            with open(md_path, "r", encoding="utf-8") as f:
                return f.read()
        except Exception as e:
            print(f"[!] Failed to read file: {e}")
            return None

    def ask_patch_suggestion(self, exploit_text):
        prompt = f"""
        You are a cybersecurity expert tasked with patching known privledge escaaltion vulnerabilities in Linux code or systems.

        Below is a potential exploit path for a vulnerability. Your job is to:

        1. Identify the vulnerability type.
        2. Describe the cause of the vulnerability.
        3. Suggest a specific patch or mitigation that developers or sysadmins can apply.
        4. Provide technical details in your patch (such as code changes, configuration updates, etc.)

        Exploit Path:
        {exploit_text}

        Respond ONLY with the patch suggestion and technical reasoning. Avoid generic advice.
        Answer in this Format
        - **Vulnerability Name**: name the vulnerability as in the exploit path file\n\n
        - **Patch**: Suggest how it can be patched or mitigated.\n\n
        ' **Affects**: Explain the affects of applying this patch\n\”
        """
        response = self.llm(prompt)
        return response.content
    
    def generate_patch(self, md_path="exploit_path.md"):
        content = self.read_md_file(md_path)
        if not content:
            print("[-] Exploit path file not found/empty.")

        patch = self.ask_patch_suggestion(content)
        return patch
