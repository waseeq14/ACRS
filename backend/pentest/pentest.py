import paramiko
import os
from openai import OpenAI
from langchain_openai import ChatOpenAI
import csv
import re
import json

class Pentest:
    def __init__(self, ssh_host, ssh_user, ssh_pass):
        self.ssh_host = ssh_host
        self.ssh_user = ssh_user
        self.ssh_pass = ssh_pass
        self.ssh_client = None

    def connect(self):
        try:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh_client.connect(self.ssh_host, port=22, username=self.ssh_user,password=self.ssh_pass, timeout=3)
            print(f"[+] Connected to {self.ssh_host}")
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            self.ssh_client = None

    def disconnect(self):
        if self.ssh_client:
            self.ssh_client.close()
            print("[+] Disconnected")
            self.ssh_client = None

    def execute_command(self, command):
        if self.ssh_client is None:
            print("[-] No active SSH connection. Please connect first.")
            return None
        try:
            stdin, stdout, stderr = self.ssh_client.exec_command(command)
            output = stdout.read().decode()
            error = stderr.read().decode()
            return output if output else error
        except Exception as e:
            print(f"[-] Command execution failed: {e}")
            return None

    def upload_file(self, local_file, remote_path):
        try:
            if self.ssh_client is None:
                print("[-] No active SSH connection.")
                return False
            sftp = self.ssh_client.open_sftp()
            sftp.put(local_file, remote_path)
            sftp.close()
            print(f"[+] Uploaded {local_file} to {remote_path}")
            return True
        except Exception as e:
            print(f"[-] File upload failed: {e}")
            return False
        
    def get_linpeas_option(self):
        options = {
            "1": "system_information",
            "2": "container,cloud",
            "3": "procs_crons_timers_srvcs_sockets",
            "4": "network_information",
            "5": "users_information",
            "6": "software_information",
            "7": "interesting_perms_files",
            "8": "interesting_files",
            "9": "api_kceys_regex"
        }
        print("\nSelect LinPEAS scan option:")
        for key, value in options.items():
            print(f"{key}. {value}")
        choice = input("Enter the number corresponding to your choice: ")
        return options.get(choice, "interesting_perms_files")  # Default option

    def verify_option(self, option):
        valid_options = ["system_information", "container,cloud", "procs_crons_timers_srvcs_sockets",
            "network_information", "users_information", "software_information",
            "interesting_perms_files", "interesting_files", "api_kceys_regex"
        ]
        if option in valid_options:
            return option
        else:
            return "interesting_perms_files"

    def create_run_script(self, option, ssh_pass):
        # selected_option = self.get_linpeas_option()
        selected_option = self.verify_option(option)
        print(ssh_pass)
        with open("run.sh", "w") as f:
            f.write("#!/bin/bash\n\n")
            f.write("OUTPUT=\"/tmp/enum_results.txt\"\n")
            f.write("echo \"[+] Running LinPEAS\" > \"$OUTPUT\"\n")
            f.write("chmod +x /tmp/linpeas.sh\n")
            if ssh_pass:
                f.write(f"bash /tmp/linpeas.sh -q -P '{ssh_pass}'  -o {selected_option} &>> \"$OUTPUT\"\n")
            else :
                f.write(f"bash /tmp/linpeas.sh -q -o {selected_option} &>> \"$OUTPUT\"\n")
            f.write("echo \"[+] LinPEAS execution complete.\" >> \"$OUTPUT\"\n")
        print("[+] run.sh script created with selected LinPEAS option.")


    def run_enum_scripts(self, option,ssh_pass):
        try:
            if self.ssh_client:
                self.upload_file(f"{os.getcwd()}/pentest/linpeas.sh", "/tmp/linpeas.sh")
                self.create_run_script(option,ssh_pass)
                self.upload_file("run.sh","/tmp/run.sh")
                self.execute_command("sed -i 's/\r$//' /tmp/run.sh")
                self.execute_script("/tmp/run.sh")
        except Exception as e:
            print(f"[-] File upload failed: {e}")


    def execute_script(self, script_path):
        try:
            if self.ssh_client is None:
                print("[-] No active SSH connection.")
                return None
            
            stdin, stdout, stderr = self.ssh_client.exec_command(f"chmod +x {script_path} && {script_path}")
            
            while not stdout.channel.exit_status_ready():
                print(stdout.readline().strip())
            print("[+] Enumeration script executed successfully.")
        
        except Exception as e:
            print(f"[-] Script execution failed: {e}")

    def download_file(self, remote_path, local_path):
        try:
            if self.ssh_client is None:
                print("[-] No active SSH connection.")
                return False
            
            sftp = self.ssh_client.open_sftp()
            sftp.get(remote_path, local_path)
            sftp.close()
            print(f"[+] Downloaded {remote_path} to {local_path}")
            return True
        except Exception as e:
            print(f"[-] File download failed: {e}")
            return False
    
    def setupEnv(self):
        OpenAI.api_key = os.getenv("OPENAI_API_KEY")
        self.llm = ChatOpenAI(model="gpt-4o", temperature=0.3)

    def analyze_vulns(self, file_path):
        with open(file_path, "r", encoding="utf-8", errors="ignore") as file:
            linpeas_output = file.read()

        messages = [
            "You are a cybersecurity expert analyzing Linux privilege escalation reports. "
            "Analyze the following LinPEAS scan output in depth. Your goal is to identify all confirmed, exploitable privilege escalation vulnerabilities ONLY — not general security issues.\n\n"
            "Focus areas to include:\n"
            "- Files with Linux capabilities like cap_setuid, cap_net_bind_service, etc.\n"
            "- SUID binaries that can be exploited (especially if listed in GTFOBins)\n"
            "- Misconfigured sudoers entries - list the file the user may have permission to and not the sudoers file\n"
            "- Writable files/directories owned by root or important services\n"
            "- Misconfigured services (e.g., Docker, cron, systemd units)\n"
            "- Exposed credentials that allow privilege escalation\n"
            "- Software CVEs only if relevant to local escalation\n\n"
            "For each vulnerability, provide:\n\n"
            "- Vulnerability Name (Do NOT include CVE IDs, just describe it concisely)\n"
            "- Detailed Description (What the vulnerability is, why it exists, and exactly how it can be exploited — NO commas inside description)\n"
            "- Exact Location (File path, service name, or configuration setting — ONLY this)\n"
            "- CVE Number (Only if absolutely certain — otherwise write 'Not Found')\n\n"
            "**IMPORTANT:**\n"
            "- Return output in pure JSON format without markdown or extra text.\n"
            "- JSON structure example:\n"
            "[\n"
            "  {\n"
            "    \"vulnerability_name\": \"Example Name\",\n"
            "    \"description\": \"Detailed description without commas inside\",\n"
            "    \"location\": \"Exact file path or service name\",\n"
            "    \"cve\": \"CVE-XXXX-YYYY\" or \"Not Found\"\n"
            "  },\n"
            "  ...\n"
            "]\n\n"
            "LinPEAS Output:\n" + linpeas_output
        ]

        response = self.llm(messages)

    # Handle response
        if hasattr(response, "content"):
            response_content = response.content
        elif isinstance(response, dict):
            response_content = response["choices"][0]["message"]["content"]
        else:
            response_content = str(response)

        print("\n[+] Raw Vulnerability Analysis:\n")
        print(response_content)

        # Important: clean any extra markdown like ```json or ```
        response_content = response_content.strip()
        if response_content.startswith("```json"):
            response_content = response_content[7:]
        if response_content.startswith("```"):
            response_content = response_content[3:]
        if response_content.endswith("```"):
            response_content = response_content[:-3]
        response_content = response_content.strip()

        output_file = "vuln_analysis.json"

        try:
            # Now safely parse JSON
            vulnerabilities = json.loads(response_content)

            with open(output_file, "w", encoding="utf-8") as f:
                json.dump(vulnerabilities, f, indent=4)

            print(f"\n[+] Analysis saved to {output_file}")

            return vulnerabilities

        except Exception as e:
            print(f"\n[-] Error processing JSON output: {e}")

# if __name__ == "__main__":
#     pentest = Pentest("192.168.64.144","aerys","1234")
    
#     #pentest = Pentest("10.10.167.27","slade","M3tahuman") #Lian_Yu - works
#     #pentest = Pentest("10.10.23.120","james","hackerrules!") #-Agent Sudo - doesnt work
#     #pentest = Pentest("10.10.56.246","jake","987654321") brooklyn nine nine - works
#     #pentest = Pentest("10.10.233.12","joker","*axA&GF8dP") #Madness - works
#lookup - works
#Bounty hacker - works
#Why Hack me (medium) -works
    
#     pentest.connect()
#     pentest.run_enum_scripts()
#     pentest.download_file("/tmp/enum_results.txt", "enum_results.txt")
#     pentest.setupEnv()
#     pentest.analyze_vulns("enum_results.txt")
    

