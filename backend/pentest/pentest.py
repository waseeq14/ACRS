import paramiko
import os
from openai import OpenAI
from langchain_openai import ChatOpenAI
import csv
import re



class Pentest:
    def __init__(self, ssh_host, ssh_user, ssh_pass):
        self.ssh_host = ssh_host
        self.ssh_user = ssh_user
        self.ssh_pass = ssh_pass
        self.ssh_client = None


    def connect(self):
        try:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh_client.connect(self.ssh_host, port=22, username=self.ssh_user,password=self.ssh_pass, timeout=3)
            print(f"[+] Connected to {self.ssh_host}")
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            self.ssh_client = None

    def disconnect(self):
        if self.ssh_client:
            self.ssh_client.close()
            print("[+] Disconnected")
            self.ssh_client = None

    def execute_command(self, command):
        if self.ssh_client is None:
            print("[-] No active SSH connection. Please connect first.")
            return None
        try:
            stdin, stdout, stderr = self.ssh_client.exec_command(command)
            output = stdout.read().decode()
            error = stderr.read().decode()
            return output if output else error
        except Exception as e:
            print(f"[-] Command execution failed: {e}")
            return None

    def upload_file(self, local_file, remote_path):
        try:
            if self.ssh_client is None:
                print("[-] No active SSH connection.")
                return False
            sftp = self.ssh_client.open_sftp()
            sftp.put(local_file, remote_path)
            sftp.close()
            print(f"[+] Uploaded {local_file} to {remote_path}")
            return True
        except Exception as e:
            print(f"[-] File upload failed: {e}")
            return False
        
    def get_linpeas_option(self):
        options = {
            "1": "system_information",
            "2": "container,cloud",
            "3": "procs_crons_timers_srvcs_sockets",
            "4": "network_information",
            "5": "users_information",
            "6": "software_information",
            "7": "interesting_perms_files",
            "8": "interesting_files",
            "9":"api_kceys_regex"
        }
        print("\nSelect LinPEAS scan option:")
        for key, value in options.items():
            print(f"{key}. {value}")
        choice = input("Enter the number corresponding to your choice: ")
        return options.get(choice, "interesting_perms_files")  # Default option

    def create_run_script(self):
        selected_option = self.get_linpeas_option()
        with open("run.sh", "w") as f:
            f.write("#!/bin/bash\n\n")
            f.write("OUTPUT=\"/tmp/enum_results.txt\"\n")
            f.write("echo \"[+] Running LinPEAS\" > \"$OUTPUT\"\n")
            f.write("chmod +x /tmp/linpeas.sh\n")
            f.write(f"/tmp/linpeas.sh -q -o {selected_option} &>> \"$OUTPUT\"\n")
            f.write("echo \"[+] LinPEAS execution complete.\" >> \"$OUTPUT\"\n")
        print("[+] run.sh script created with selected LinPEAS option.")


    def run_enum_scripts(self):
        try:
            if self.ssh_client:
                self.upload_file("linpeas.sh", "/tmp/linpeas.sh")
                self.create_run_script()
                self.upload_file("run.sh","/tmp/run.sh")
                self.execute_command("sed -i 's/\r$//' /tmp/run.sh")
                self.execute_script("/tmp/run.sh")
        except Exception as e:
            print(f"[-] File upload failed: {e}")


    def execute_script(self, script_path):
        try:
            if self.ssh_client is None:
                print("[-] No active SSH connection.")
                return None
            
            stdin, stdout, stderr = self.ssh_client.exec_command(f"chmod +x {script_path} && {script_path}")
            
            while not stdout.channel.exit_status_ready():
                print(stdout.readline().strip())
            print("[+] Enumeration script executed successfully.")
        
        except Exception as e:
            print(f"[-] Script execution failed: {e}")

    def download_file(self, remote_path, local_path):
        try:
            if self.ssh_client is None:
                print("[-] No active SSH connection.")
                return False
            
            sftp = self.ssh_client.open_sftp()
            sftp.get(remote_path, local_path)
            sftp.close()
            print(f"[+] Downloaded {remote_path} to {local_path}")
            return True
        except Exception as e:
            print(f"[-] File download failed: {e}")
            return False
    
    def setupEnv(self):
        OpenAI.api_key = os.getenv("OPENAI_API_KEY")
        self.llm = ChatOpenAI(model="gpt-4o", temperature=0.3)

   

    def analyze_vulns(self, file_path):
        with open(file_path, "r", encoding="utf-8", errors="ignore") as file:
            linpeas_output = file.read()

        messages = [
            
            "You are a cybersecurity expert analyzing Linux privilege escalation reports. "
            "Analyze the following LinPEAS scan output in depth. Your goal is to identify all confirmed, exploitable privilege escalation vulnerabilities ONLY — not general security issues.\n\n"

            "Focus areas to include:\n"
            "- Files with Linux capabilities like cap_setuid, cap_net_bind_service, etc.\n"
            "- SUID binaries that can be exploited (especially if listed in GTFOBins)\n"
            "- Misconfigured sudoers entries\n"
            "- Writable files/directories owned by root or important services\n"
            "- Misconfigured services (e.g. Docker, cron, systemd units)\n"
            "- Exposed credentials that allow privilege escalation\n"
            "- Software CVEs only if relevant to local escalation\n\n"

            "For each vulnerability, provide:\n\n"
            "- **Vulnerability Name** (Do NOT include CVE IDs, just describe it concisely or Name it)\n"
            "- **Detailed Description** (Include what the vulnerability is, why it exists, and how it can be exploited in detail — describe the attack process clearly here and Donot add a Comma!!)\n"
            "- **Exact Location** (Only the specific file path, service name, or configuration setting — do NOT include anything else)\n\n"
            "- **CVE number** (Only give CVE number if you are absolutely Certain - else return Not Found)\n\n"    
            "Output the result in CSV format with exactly 4 columns (no headers):\n"
            "[Vulnerability Name, Description, Location, CVE]\n\n"
            "Do NOT wrap the response in markdown, triple backticks, or extra text.\n\n"
            "LinPEAS Output:\n" + linpeas_output

        ]

        response = self.llm(messages)

         # Extract content correctly depending on the library you're using
        if hasattr(response, "content"):
            response_content = response.content
        elif isinstance(response, dict):
            response_content = response["choices"][0]["message"]["content"]
        else:
            response_content = str(response)

        print("\n[+] Vulnerability Analysis:\n")
        print(response_content)

        output_file = "vuln_analysis.csv"

        try:
            csv_lines = response_content.strip().split("\n")
            csv_lines = [line.strip() for line in csv_lines if line.strip() and not line.strip().startswith("```")]

            with open(output_file, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                writer.writerow(["Vulnerability Name", "Description", "Location", "CVE"])  # Updated header

                for line in csv_lines:
                    # Regex to match four fields: name, description, location, CVE
                    parts = re.match(r"^(.*?),\s*(.*?),\s*(.*?),\s*([^,]+)$", line)
                    if parts:
                        name, desc, loc, cve = parts.groups()
                        writer.writerow([name.strip(), desc.strip(), loc.strip(), cve.strip()])
                    else:
                        print(f"[!] Skipped malformed line: {line}")

            print(f"\n[+] Analysis saved to {output_file}")

        except Exception as e:
            print(f"\n[-] Error writing to CSV file: {e}")



if __name__ == "__main__":
    pentest = Pentest("10.10.63.72","james","hackerrules!")
    pentest.connect()
    pentest.run_enum_scripts()
    pentest.download_file("/tmp/enum_results.txt", "enum_results.txt")
    pentest.setupEnv()
    pentest.analyze_vulns("enum_results.txt")
    

