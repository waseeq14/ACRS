import os
import subprocess
import json
from langchain_openai import OpenAI
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from dotenv import load_dotenv
from langchain.schema.runnable import RunnablePassthrough, RunnableSequence
import re
from langchain.chat_models import ChatOpenAI
import warnings
import threading
from vulnerability_analysis.aflSetup.crash_analyzer import CrashAnalyzer
import re

# Suppress all warnings
warnings.filterwarnings("ignore")


class AFLPIPELINE:
	def __init__(self, source_path, binary_path, llm, folder_path):
		self.source_path = source_path
		self.binary_path = binary_path
		self.folder_path = folder_path
		self.llm = llm
		self.inputDir = f"{folder_path}/in"
		self.outputDir = f"{folder_path}/out"
		self.separator = "###"
		os.makedirs(self.inputDir, exist_ok=True)
		os.makedirs(self.outputDir, exist_ok=True)

	def clean_code(self, llm_output):
		"""Removes leading and trailing ```c or ``` from the LLM output."""
		return re.sub(r"^```c\n|```$", "", llm_output.strip(), flags=re.MULTILINE)

	def make_fuzzer_friendly(self):
		"""Passes the C source code to LLM to check if it already takes input from a file.
		If not, modifies it to be fuzzer-compatible by replacing command-line input or stdin with file input.
		"""
		with open(self.source_path, "r") as f:
			source_code = f.read()

		print("[+] Passing the source code to LLM for analysis...")

		# LLM Prompt to determine if modification is needed
		check_prompt = PromptTemplate(
			template=(
				"Analyze the following C program and determine if it already reads input from a file "
				"(using `fopen`, `ifstream`, or similar methods). If it does, return the same code. "
				"Otherwise, modify it to replace command-line arguments (`argc, argv[]`) or standard "
				"input (`stdin`, `std::cin`) with file-based input (`fopen` or `ifstream`)., with file name being passed to as command line argument."
				"Just return the code, nothing else, no formatting.\n\n"
				"Original Code:\n"
				"```c\n{source_code}\n```\n\n"
				"Corrected Code (if needed):"
			),
			input_variables=["source_code"]
		)

		llm_chain = LLMChain(llm=self.llm, prompt=check_prompt)
		modified_code = llm_chain.run({"source_code": source_code})
		modified_code = self.clean_code(modified_code)

		# if modified_code.strip() == source_code.strip():
		# 	print("[+] LLM confirmed the code is already fuzzer-friendly. No changes needed.")
		# 	return source_code  # Return the original code

		# Define new source file path
		modified_source_path = self.source_path.replace(".c", "_fuzz.c")

		# Save the modified code in a new file
		with open(modified_source_path, "w") as f:
			f.write(modified_code)

		print(f"[+] Code saved to `{modified_source_path}`")

		# Update source path to use modified code
		self.source_path = modified_source_path

		return modified_code


	def generate_seeds_with_llm(self):
		"""Use LangChain to generate structured fuzzing seeds with a custom separator."""
		print(f"[+] Generating fuzzing seeds using LLM with separator `{self.separator}`...")

		with open(self.source_path, "r") as f:
			source_code = f.read()

		# Define prompt template for generating structured inputs
		prompt = PromptTemplate(
			template=(
				"Analyze the following C program and generate five valid test case inputs "
				"formatted correctly based on expected user input."
				"TEST CASES SHOULD NOT CRASH THE PROGRAM, as afl wont work then."
				"FOLLOW THESE RULES:\n"
				"Dont mark them like 1) 2)\n"
				"Dont give them any heading\n"
				"Seperate each test case with a new line\n"
				"Each test case should use `{separator}` as a separator between multiple inputs.\n\n"
				"```c\n{source_code}\n```\n\n"
				"Example format:\n"
				"input1{separator}input2{separator}input3\n"
			),
			input_variables=["source_code", "separator"]
		)

		llm_chain = LLMChain(llm=self.llm, prompt=prompt)
		generated_text = llm_chain.run({"source_code": source_code, "separator": self.separator})
		print(generated_text)

		# Split responses by separator
		seeds = generated_text.strip().split("\n")

		if not seeds or len(seeds) < 2:
			print("[-] No valid seeds generated by LLM.")
			return

		# Store generated seeds as input files
		for i, seed in enumerate(seeds):
			with open(f"{self.inputDir}/seed_{i}.txt", "w") as f:
				f.write(seed.replace(self.separator, "\n"))  # Convert separator to newlines

		print(f"[+] Generated {len(seeds)} seeds using `{self.separator}` and stored in `{self.inputDir}`.")

		return generated_text

	def compile_code(self):
		"""Compile the source code with AFL++ instrumentation if needed."""
		if self.source_path.endswith(".c") or self.source_path.endswith(".cpp"):
			print("[+] Compiling source code with AFL++...")
			if ".cpp" in self.source_path:
				compile_cmd = f"afl-cc -fsanitize=address,undefined -ggdb -O0 {self.source_path} -o {self.binary_path} -lstdc++ -lubsan"
			else:
				compile_cmd = f"afl-cc -fsanitize=address,undefined -ggdb -O0 {self.source_path} -o {self.binary_path}"
			result = subprocess.run(compile_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

			if result.returncode == 0:
				print("[+] Compilation successful!")
			else:
				print(f"[-] Compilation failed: {result.stderr.decode()}")


	def run_afl_fuzz(self):
	    """Run AFL++ while capturing output and allowing the user to stop it."""
	    print("[+] Starting AFL++ fuzzing... Press Enter to stop.")

	    afl_cmd = f"afl-fuzz -i {self.inputDir} -o {self.outputDir} -V 100 -m none -- {self.binary_path} @@"

	    # Start AFL++ in a subprocess
	    process = subprocess.Popen(afl_cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

	    # Function to read and print AFL++ output in real-time
	    def stream_output():
	        try:
	            for line in iter(process.stdout.readline, ''):
	                print(line, end='', flush=True)  # Print AFL++ output in real-time
	        except Exception as e:
	            print(f"[-] Error capturing AFL++ output: {e}")

	    # Start output streaming in a separate thread
	    output_thread = threading.Thread(target=stream_output)
	    output_thread.start()
	    try:
	        input("\nPress Enter to stop fuzzing...\n")  # Wait for user input

	        print("[+] Stopping AFL++ fuzzing...")
	        process.terminate()  # Send SIGTERM

	    except KeyboardInterrupt:
	        print("\n[+] Stopping AFL++ due to keyboard interrupt...")
	        process.terminate()
	        try:
	            process.wait(timeout=5)
	        except subprocess.TimeoutExpired:
	            process.kill()

	    output_thread.join()  # Ensure the output thread stops before proceeding
	    print("[+] AFL++ fuzzing stopped successfully.")


