#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void init_buffer(char *buffer, int size) {
    for (int i = 0; i < size; i++) {
        buffer[i] = '\0';
    }
}

void pseudo_encrypt(char *input, char *output) {
    char stack_buffer[32];
    init_buffer(stack_buffer, 32);
    strcpy(stack_buffer, input); // Stack-based buffer overflow
    for (int i = 0; stack_buffer[i]; i++) {
        output[i] = stack_buffer[i] ^ 0x5A; // Simple XOR "encryption"
    }
    printf("Encrypted: %s\n", output);
}

void hash_string(char *input, int len, char *hash_out) {
    char temp_buffer[64];
    init_buffer(temp_buffer, 64);
    if (len > 0) {
        strncpy(temp_buffer, input, len); // Partial copy, still unsafe
        for (int i = 0; temp_buffer[i]; i++) {
            hash_out[i] = temp_buffer[i] + i; // Simple "hash"
        }
    } else {
        strcat(temp_buffer, input); // Unsafe concatenation
        strcpy(hash_out, temp_buffer);
    }
    printf("Hashed: %s\n", hash_out);
}

int key_sum(int key1, int key2) {
    int sum = key1 + key2; // Potential integer overflow
    if (sum < key1 || sum < key2) {
        printf("Key sum overflow!\n");
        return -1;
    }
    return sum;
}

void encrypt_heap(char *input, int size) {
    char *heap_buffer = malloc(size);
    if (!heap_buffer) {
        printf("Allocation failed!\n");
        return;
    }
    strcpy(heap_buffer, input); // Heap-based buffer overflow
    for (int i = 0; heap_buffer[i]; i++) {
        heap_buffer[i] ^= 0x3C; // Another XOR "encryption"
    }
    printf("Heap encrypted: %s\n", heap_buffer);
    free(heap_buffer);
}

void key_rotation(char *input) {
    char *temp = malloc(50);
    if (!temp) return;
    strcpy(temp, input);
    free(temp);
    printf("Rotated key: %s\n", temp); // Use-after-free
}

void hash_cleanup(char *input) {
    char *buffer = malloc(20);
    if (!buffer) return;
    strcpy(buffer, input);
    free(buffer);
    free(buffer); // Double free
    printf("Hash cleanup completed\n");
}

void derive_key(int value, char *input, char *key_out) {
    int result = key_sum(value, 2000000000);
    if (result == -1) {
        printf("Key derivation failed\n");
        return;
    }
    char *dynamic = malloc(result % 1000);
    if (dynamic) {
        strcpy(dynamic, input); // Another heap overflow
        for (int i = 0; dynamic[i]; i++) {
            key_out[i] = dynamic[i] ^ (result & 0xFF);
        }
        free(dynamic);
    }
    printf("Derived key: %s\n", key_out);
}

void process_encrypt(char *input) {
    char output[512];
    init_buffer(output, 512);
    pseudo_encrypt(input, output);
    hash_string(input, strlen(input), output);
}

void process_hash(char *input, int size) {
    char hash[512];
    init_buffer(hash, 512);
    encrypt_heap(input, size);
    key_rotation(input);
}

void process_cleanup(char *input) {
    char hash[512];
    init_buffer(hash, 512);
    hash_cleanup(input);
    hash_string(input, 10, hash);
}

void process_key_derivation(char *input, int value) {
    char key[512];
    init_buffer(key, 512);
    derive_key(value, input, key);
    pseudo_encrypt(input, key);
}

void process_combine(char *input) {
    char combined[128];
    init_buffer(combined, 128);
    strcat(combined, input); // Unsafe concatenation
    for (int i = 0; combined[i]; i++) {
        combined[i] ^= 0x1F; // Another "encryption"
    }
    printf("Combined output: %s\n", combined);
}

void execute_crypto_op(char *input, int key, int choice) {
    switch (choice) {
        case 1:
            process_encrypt(input);
            break;
        case 2:
            process_hash(input, 16);
            break;
        case 3:
            process_cleanup(input);
            break;
        case 4:
            process_key_derivation(input, key);
            break;
        case 5:
            process_combine(input);
            break;
        default:
            printf("Invalid operation\n");
    }
}

int validate_input(char *input, int key) {
    if (strlen(input) > 500) {
        printf("Input too long!\n");
        return 0;
    }
    if (key < -1000000 || key > 1000000) {
        printf("Key out of range!\n");
        return 0;
    }
    return 1;
}

void print_crypto_menu() {
    printf("\n=== Crypto System Menu ===\n");
    printf("1. Encrypt String\n");
    printf("2. Hash String\n");
    printf("3. Cleanup Hash\n");
    printf("4. Derive Key\n");
    printf("5. Combine Operations\n");
    printf("Enter choice (1-5): ");
}

int main() {
    char input[512];
    int key, choice;

    printf("Welcome to Crypto Hash System\n");
    printf("Enter input string (max 500 chars): ");
    fgets(input, sizeof(input), stdin);
    input[strcspn(input, "\n")] = 0;

    printf("Enter encryption key (number): ");
    scanf("%d", &key);

    if (!validate_input(input, key)) {
        return 1;
    }

    print_crypto_menu();
    scanf("%d", &choice);

    if (choice < 1 || choice > 5) {
        printf("Invalid choice! Exiting.\n");
        return 1;
    }

    execute_crypto_op(input, key, choice);

    // Additional processing paths
    if (key > 5000) {
        char *extra_buffer = malloc(100);
        if (extra_buffer) {
            strcpy(extra_buffer, input); // Another heap overflow
            for (int i = 0; extra_buffer[i]; i++) {
                extra_buffer[i] ^= 0x2B;
            }
            printf("Extra encrypted: %s\n", extra_buffer);
            free(extra_buffer);
        }
    } else if (key < -5000) {
        key_rotation(input);
    } else {
        pseudo_encrypt(input, input);
    }

    // Simulate chained operations
    for (int i = 0; i < 3; i++) {
        if (choice == i + 1) {
            char temp[512];
            init_buffer(temp, 512);
            hash_string(input, i * 10, temp);
        }
    }

    // Final operation
    char final_buffer[64];
    init_buffer(final_buffer, 64);
    strcat(final_buffer, input); // Unsafe concatenation
    for (int i = 0; final_buffer[i]; i++) {
        final_buffer[i] ^= 0x4D;
    }
    printf("Final output: %s\n", final_buffer);

    return 0;
}