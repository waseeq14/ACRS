#include <klee/klee.h>
#include <stdlib.h>
#include <string.h>

void init_buffer(char *buffer, int size) {
    for (int i = 0; i < size; i++) {
        buffer[i] = '\0';
    }
}

void pseudo_encrypt(char *input, char *output) {
    char stack_buffer[32];
    init_buffer(stack_buffer, 32);
    strcpy(stack_buffer, input);
    for (int i = 0; stack_buffer[i]; i++) {
        output[i] = stack_buffer[i] ^ 0x5A;
    }
}

void hash_string(char *input, int len, char *hash_out) {
    char temp_buffer[64];
    init_buffer(temp_buffer, 64);
    if (len > 0) {
        strncpy(temp_buffer, input, len);
        for (int i = 0; temp_buffer[i]; i++) {
            hash_out[i] = temp_buffer[i] + i;
        }
    } else {
        strcat(temp_buffer, input);
        strcpy(hash_out, temp_buffer);
    }
}

int key_sum(int key1, int key2) {
    int sum = key1 + key2;
    if (sum < key1 || sum < key2) {
        return -1;
    }
    return sum;
}

void encrypt_heap(char *input, int size) {
    char *heap_buffer = malloc(size);
    if (!heap_buffer) {
        return;
    }
    strcpy(heap_buffer, input);
    for (int i = 0; heap_buffer[i]; i++) {
        heap_buffer[i] ^= 0x3C;
    }
    free(heap_buffer);
}

void key_rotation(char *input) {
    char *temp = malloc(50);
    if (!temp) return;
    strcpy(temp, input);
    free(temp);
}

void hash_cleanup(char *input) {
    char *buffer = malloc(20);
    if (!buffer) return;
    strcpy(buffer, input);
    free(buffer);
    free(buffer);
}

void derive_key(int value, char *input, char *key_out) {
    int result = key_sum(value, 2000000000);
    if (result == -1) {
        return;
    }
    char *dynamic = malloc(result % 1000);
    if (dynamic) {
        strcpy(dynamic, input);
        for (int i = 0; dynamic[i]; i++) {
            key_out[i] = dynamic[i] ^ (result & 0xFF);
        }
        free(dynamic);
    }
}

void process_encrypt(char *input) {
    char output[512];
    init_buffer(output, 512);
    pseudo_encrypt(input, output);
    hash_string(input, strlen(input), output);
}

void process_hash(char *input, int size) {
    char hash[512];
    init_buffer(hash, 512);
    encrypt_heap(input, size);
    key_rotation(input);
}

void process_cleanup(char *input) {
    char hash[512];
    init_buffer(hash, 512);
    hash_cleanup(input);
    hash_string(input, 10, hash);
}

void process_key_derivation(char *input, int value) {
    char key[512];
    init_buffer(key, 512);
    derive_key(value, input, key);
    pseudo_encrypt(input, key);
}

void process_combine(char *input) {
    char combined[128];
    init_buffer(combined, 128);
    strcat(combined, input);
    for (int i = 0; combined[i]; i++) {
        combined[i] ^= 0x1F;
    }
}

void execute_crypto_op(char *input, int key, int choice) {
    switch (choice) {
        case 1:
            process_encrypt(input);
            break;
        case 2:
            process_hash(input, 16);
            break;
        case 3:
            process_cleanup(input);
            break;
        case 4:
            process_key_derivation(input, key);
            break;
        case 5:
            process_combine(input);
            break;
    }
}

int validate_input(char *input, int key) {
    if (strlen(input) > 500) {
        return 0;
    }
    if (key < -1000000 || key > 1000000) {
        return 0;
    }
    return 1;
}

int main() {
    char input[512];
    int key, choice;

    klee_make_symbolic(input, sizeof(input), "input");
    klee_make_symbolic(&key, sizeof(key), "key");
    klee_make_symbolic(&choice, sizeof(choice), "choice");

    if (!validate_input(input, key)) {
        return 1;
    }

    if (choice < 1 || choice > 5) {
        return 1;
    }

    execute_crypto_op(input, key, choice);

    if (key > 5000) {
        char *extra_buffer = malloc(100);
        if (extra_buffer) {
            strcpy(extra_buffer, input);
            for (int i = 0; extra_buffer[i]; i++) {
                extra_buffer[i] ^= 0x2B;
            }
            free(extra_buffer);
        }
    } else if (key < -5000) {
        key_rotation(input);
    } else {
        pseudo_encrypt(input, input);
    }

    for (int i = 0; i < 3; i++) {
        if (choice == i + 1) {
            char temp[512];
            init_buffer(temp, 512);
            hash_string(input, i * 10, temp);
        }
    }

    char final_buffer[64];
    init_buffer(final_buffer, 64);
    strcat(final_buffer, input);
    for (int i = 0; final_buffer[i]; i++) {
        final_buffer[i] ^= 0x4D;
    }

    return 0;
}